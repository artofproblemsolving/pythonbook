..  Copyright (C) 2014 AoPS Incorporated
..  Copyright (C)  Peter Wentworth, Jeffrey Elkner, Allen B. Downey and Chris Meyers.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with Invariant Sections being Foreword, Preface, and Contributor List, no
    Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is
    included in the section entitled "GNU Free Documentation License".
 
|      
    
Recursion
========= 

**Recursion** means "defining something in terms of itself" usually at some 
smaller scale, perhaps multiple times, to achieve your objective.  
For example, we might say "A human being is someone whose mother is a human being",
or "a directory is a structure that holds files and (smaller) directories", or "a family tree starts
with a couple who have children, each with their own family sub-trees".

Programming languages generally support **recursion**, which means that, in order
to solve a problem, functions can *call themselves* to solve smaller subproblems.  
   
Drawing Fractals
----------------

For our purposes, a **fractal** is a drawing which also has *self-similar* structure,
where it can be defined in terms of itself.

Let us start by looking at the famous Koch fractal.  An order 0 Koch fractal is simply
a straight line of a given size.

.. image:: illustrations/koch_0.png

An order 1 Koch fractal is obtained like this: instead of drawing just one line,
draw instead four smaller segments, in the pattern shown here:

.. image:: illustrations/koch_1.png

Now what would happen if we repeated this Koch pattern again on each of the order 1 segments?  
We'd get this order 2 Koch fractal:

.. image:: illustrations/koch_2.png

Repeating our pattern again gets us an order 3 Koch fractal:

.. image:: illustrations/koch_3.png

Now let us think about it the other way around.  To draw a Koch fractal
of order 3, we can simply draw four order 2 Koch fractals.  But each of these
in turn needs four order 1 Koch fractals, and each of those in turn needs four
order 0 fractals.  Ultimately, the only drawing that will take place is 
at order 0. This is very simple to code up in Python:

.. activecode:: kochexample
   :cwidth: 600
   
   def koch(t, order, size):
       """
          Make turtle t draw a Koch fractal of 'order' and 'size'.
          Leave the turtle facing the same direction.
       """

       if order == 0:          # The base case is just a straight line
           t.forward(size)
       else:
           koch(t, order-1, size/3)   # Go 1/3 of the way
           t.left(60)
           koch(t, order-1, size/3)
           t.right(120)
           koch(t, order-1, size/3)
           t.left(60)
           koch(t, order-1, size/3) 

   import turtle
   wn = turtle.Screen()
   t = turtle.Turtle()
   koch(t, 3, 300)
   wn.mainloop()
            
The key thing that is new here is that if order is not zero,
``koch`` calls itself recursively to get its job done.

Let's make a simple observation and tighten up this code.  Remember that
turning right by 120 is the same as turning left by -120.  So with a 
bit of clever rearrangement, we can use a loop instead of lines 10-16:

.. activecode:: kochsimpler
   :cwidth: 600

   def koch(t, order, size):
       if order == 0:                  
           t.forward(size)
       else:
           for angle in [60, -120, 60, 0]:
              koch(t, order-1, size/3)   
              t.left(angle)

   import turtle
   wn = turtle.Screen()
   t = turtle.Turtle()
   koch(t, 3, 300)
   wn.mainloop()
               
The final turn is 0 degrees --- so it has no effect.  But it has allowed us to
find a pattern and reduce seven lines of code to three, which will make  
things easier for our next observations.

One way to think about this is to convince yourself that the function
works correctly when you call it for an order 0 fractal.  Then do
a mental *leap of faith*, saying *"the fairy godmother* (or Python, if
you can think of Python as your fairy godmother) *knows how to 
handle the recursive level 0 calls for me on lines 11, 13, 15, and 17, so
I don't need to think about that detail!"*  All I need to focus on
is how to draw an order 1 fractal *if I can assume the order 0 one is
already working.*

You're practicing *mental abstraction* --- ignoring the subproblem 
while you solve the big problem.

If this mode of thinking works (and you should practice it!), then take
it to the next level.  Aha! now can I see that it will work when called
for order 2 *under the assumption that it is already working for level 1*.  

And, in general, if I can assume the order n-1 case works, can I just 
solve the level n problem?

Students of mathematics who have played with proofs of induction should
see some very strong similarities here.  

Another way of trying to understand recursion is to get rid of it! If we
had separate functions to draw a level 3 fractal, a level 2 fractal, a level 1
fractal and a level 0 fractal, we could simplify the above code, quite mechanically,
to a situation where there was no longer any recursion, like this:

.. activecode:: kochnonrecurse
	
   def koch_0(t, size):
       t.forward(size)

   def koch_1(t, size):
       for angle in [60, -120, 60, 0]:
           koch_0(t, size/3)
           t.left(angle)

   def koch_2(t, size):
       for angle in [60, -120, 60, 0]:
           koch_1(t, size/3)
           t.left(angle)

   def koch_3(t, size):
       for angle in [60, -120, 60, 0]:
           koch_2(t, size/3)
           t.left(angle)

   import turtle
   wn = turtle.Screen()
   t = turtle.Turtle()
   koch(t, 3, 300)
   wn.mainloop()
    
This trick of "unrolling" the recursion gives us an operational view
of what happens.  You can trace the program into ``koch_3``, and from
there, into ``koch_2``, and then into ``koch_1``, etc., all the way down
the different layers of the recursion.  

This might be a useful hint to build your understanding.  The mental goal
is, however, to be able to do the abstraction!

.. index::
    single: data structure
    single: data structure; recursive
    single: recursive definition
    single: definition; recursive
    single: recursive data structure
       
Recursive data structures
-------------------------

All of the Python data types we have seen can be grouped inside lists and
tuples in a variety of ways. Lists and tuples can also be nested, providing 
many possibilities for organizing data. The organization of data for the
purpose of making it easier to use is called a **data structure**.

It's election time and we are helping to compute the votes as they come in.
Votes arriving from individual wards, precincts, municipalities, counties, and
states are sometimes reported as a sum total of votes and sometimes as a list
of subtotals of votes. After considering how best to store the tallies, we
decide to use a *nested number list*, which we define as follows:

A *nested number list* is a list whose elements are either:

a. numbers
b. nested number lists

Notice that the term, *nested number list* is used in its own definition.
**Recursive definitions** like this are quite common in mathematics and
computer science. They provide a concise and powerful way to describe
**recursive data structures** that are partially composed of smaller and
simpler instances of themselves. The definition is not circular, since at some
point we will reach a list that does not have any lists as elements.

Now suppose our job is to write a function that will sum all of the values in a
nested number list. Python has a built-in function which finds the sum of a
sequence of numbers:

.. activecode:: sumworks
    
   print(sum([1, 2, 8]))

For our *nested number list*, however, ``sum`` will not work:

.. activecode:: sumdoesnotwork
    
   print(sum([1, 2, [11, 13], 8]))

The problem is that the third element of this list, ``[11, 13]``, is itself a
list, so it cannot just be added to ``1``, ``2``, and ``8``.

.. index:: recursion, recursive call, base case, infinite recursion, recursion; infinite

Processing recursive number lists
---------------------------------

To sum all the numbers in our recursive nested number list we need to traverse
the list, visiting each of the elements within its nested structure, adding any
numeric elements to our sum, and *recursively repeating the summing process* with any elements
which are themselves sub-lists.

Thanks to recursion, the Python code needed to sum the values of a nested number list is
surprisingly short:

.. activecode:: sumnestedlist
    :linenos: 
    
   def r_sum(nested_num_list):
       tot = 0
       for element in nested_num_list:
           if type(element) == type([]):
               tot += r_sum(element)
           else:
               tot += element
       return tot

   print(r_sum([1, 2, [11, 13], 8]))
   # should be 1+2+11+13+8 = 35

The body of ``r_sum`` consists mainly of a ``for`` loop that traverses
``nested_num_list``. If ``element`` is a numerical value (the ``else`` branch),
it is simply added to ``tot``. If ``element`` is a list, then ``r_sum``
is called again, with the element as an argument.  The statement inside the
function definition in which the function calls itself is known as the
**recursive call**.

The example above has a **base case** (on line 7) which does not lead to a
recursive call: the case where the element is not a (sub-) list. Without
a base case, you'll have **infinite recursion**, and your program will not work.

Recursion is truly one of the most beautiful and elegant tools in computer
science.

A slightly more complicated problem is finding the largest value in our nested
number list:

.. activecode:: maxnestedlist
    
   def r_max(nxs):
       """ 
         Find the maximum in a recursive structure of lists 
         within other lists.
         Precondition: No lists or sublists are empty. 
       """
       largest = None 
       first_time = True
       for e in nxs:
           if type(e) == type([]):
               val = r_max(e)
           else:
               val = e
                
           if first_time or val > largest:
               largest = val
               first_time = False

       return largest
        
   print(r_max([2, 9, [1, 13], 8, 6]))  # should be 13
   print(r_max([2, [[100, 7], 90], [1, 13], 8, 6]))  # should be 100
   print(r_max([[[13, 7], 90], 2, [1, 100], 8, 6]))  # should be 100
   print(r_max(["joe", ["sam", "ben"]]))  # should be "sam"

Tests are included to provide examples of ``r_max`` at work. 

The added twist to this problem is finding a value for initializing
``largest``. We can't just use ``nxs[0]``, since that could be either
a element or a list. To solve this problem (at every recursive call)
we initialize a Boolean flag (at line 8).  When we've found the value of interest,
(at line 15)
we check to see whether this is the initializing (first) value for
``largest``, or a value that could potentially change ``largest``.

Again here we have a base case at line 13.  If we don't supply a base case,
Python stops after reaching a maximum recursion depth and returns a runtime
error.  See how this happens, by running this little script which we will call `infinite_recursion.py`: 

.. activecode:: infiniterecursion
    
   def recursion_depth(number):
       print(str(number), end=",")
       recursion_depth(number + 1)

   recursion_depth(0)


.. index:: fibonacci numbers

Case study: Fibonacci numbers  
----------------------------- 

The famous **Fibonacci sequence** 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 134, ... was devised by 
Fibonacci (1170-1250), who used this to model the breeding of (pairs) of rabbits.   
If, in generation 7 you had 21 pairs in total, of which 13 were adults, 
then next generation the adults will all have bred new children, 
and the previous children will have grown up to become adults.  
So in generation 8 you'll have 13+21=34, of which 21 are adults.

This *model* to explain rabbit breeding made the simplifying assumption that rabbits never died. 
Scientists often make (unrealistic) simplifying assumptions and restrictions 
to make some headway with the problem.

If we number the terms of the sequence from 0, we can describe each term recursively
as the sum of the previous two terms::
 
    fib(0) = 0
    fib(1) = 1
    fib(n) = fib(n-1) + fib(n-2)  for n >= 2

This translates very directly into some Python: 

.. activecode:: fibrecurse

   def fib(n):
       if n <= 1:
           return n
       t = fib(n-1) + fib(n-2)
       return t

   print(fib(10))  # should print 55

This is a particularly inefficient algorithm. Change the 10 to 30 in line 7 of the code above and see how slowly it runs. Can you think of a faster way to implement this algorithm?
    
Glossary
--------

.. glossary::

    base case
        A branch of the conditional statement in a recursive function that does
        not give rise to further recursive calls.

    infinite recursion
        A function that calls itself recursively without ever reaching any base
        case. Eventually, infinite recursion causes a runtime error.

    recursion
        The process of calling a function that is already executing.

    recursive call
        The statement that calls an already executing function.  Recursion can
        also be indirect --- function `f` can call `g` which calls `h`, 
        and `h` could make a call back to `f`.

    recursive definition
        A definition which defines something in terms of itself. To be useful
        it must include *base cases* which are not recursive. In this way it
        differs from a *circular definition*.  Recursive definitions often
        provide an elegant way to express complex data structures, like a directory
        that can contain other directories, or a menu that can contain other menus.

